[{"/Users/ngw/Documents/Sites/Pianopet/client/src/index.js":"1","/Users/ngw/Documents/Sites/Pianopet/client/src/App.js":"2","/Users/ngw/Documents/Sites/Pianopet/client/src/reportWebVitals.js":"3","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Dashboard.js":"4","/Users/ngw/Documents/Sites/Pianopet/client/src/AppContext.js":"5","/Users/ngw/Documents/Sites/Pianopet/client/src/utils/index.js":"6","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Guest.js":"7","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Loading.js":"8","/Users/ngw/Documents/Sites/Pianopet/client/src/components/MiniMenu.js":"9","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Modal.js":"10","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Student.js":"11","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Teacher.js":"12","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Marketplace.js":"13","/Users/ngw/Documents/Sites/Pianopet/client/src/components/ViewStudent.js":"14","/Users/ngw/Documents/Sites/Pianopet/client/src/components/ContextMenu.js":"15","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Dropdown.js":"16","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Avatar.js":"17","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Closet.js":"18","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Button.js":"19","/Users/ngw/Documents/Sites/Pianopet/client/src/components/MyAccount.js":"20","/Users/ngw/Documents/Sites/Pianopet/client/src/components/PianopetBase.js":"21","/Users/ngw/Documents/Sites/Pianopet/client/src/utils/ntc.js":"22","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Splat.js":"23"},{"size":500,"mtime":1607403407622,"results":"24","hashOfConfig":"25"},{"size":3282,"mtime":1614647672130,"results":"26","hashOfConfig":"25"},{"size":362,"mtime":1607403407623,"results":"27","hashOfConfig":"25"},{"size":1826,"mtime":1614419589385,"results":"28","hashOfConfig":"25"},{"size":97,"mtime":1607733049448,"results":"29","hashOfConfig":"30"},{"size":617,"mtime":1613104797140,"results":"31","hashOfConfig":"25"},{"size":8716,"mtime":1614306014271,"results":"32","hashOfConfig":"25"},{"size":400,"mtime":1614420066265,"results":"33","hashOfConfig":"25"},{"size":684,"mtime":1612233978520,"results":"34","hashOfConfig":"30"},{"size":965,"mtime":1612233987275,"results":"35","hashOfConfig":"25"},{"size":13222,"mtime":1614650096481,"results":"36","hashOfConfig":"25"},{"size":15071,"mtime":1614647513478,"results":"37","hashOfConfig":"25"},{"size":37443,"mtime":1614676531908,"results":"38","hashOfConfig":"25"},{"size":17774,"mtime":1614650231161,"results":"39","hashOfConfig":"25"},{"size":908,"mtime":1614420880876,"results":"40","hashOfConfig":"25"},{"size":4849,"mtime":1614653461718,"results":"41","hashOfConfig":"25"},{"size":1354,"mtime":1614650252738,"results":"42","hashOfConfig":"25"},{"size":4194,"mtime":1614648999236,"results":"43","hashOfConfig":"25"},{"size":1834,"mtime":1613715784896,"results":"44","hashOfConfig":"25"},{"size":6253,"mtime":1613975599081,"results":"45","hashOfConfig":"25"},{"size":1784,"mtime":1614323810625,"results":"46","hashOfConfig":"25"},{"size":44387,"mtime":1614317676027,"results":"47","hashOfConfig":"25"},{"size":2959,"mtime":1614319325962,"results":"48","hashOfConfig":"25"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},"1e1hwtf",{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"60"},"sahw5t",{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"51"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"51"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"51"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"99"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},"/Users/ngw/Documents/Sites/Pianopet/client/src/index.js",[],["102","103"],"/Users/ngw/Documents/Sites/Pianopet/client/src/App.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/reportWebVitals.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Dashboard.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/AppContext.js",[],["104","105"],"/Users/ngw/Documents/Sites/Pianopet/client/src/utils/index.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Guest.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Loading.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/MiniMenu.js",[],["106","107"],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Modal.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Student.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Teacher.js",["108","109"],"import { useState, useEffect, useRef } from 'react';\nimport { Dashboard, Header, Sidebar, Nav } from './Dashboard';\nimport ViewStudent from './ViewStudent';\nimport Marketplace, { AddOrEditWearable } from './Marketplace';\nimport Loading from './Loading';\nimport ContextMenu from './ContextMenu';\nimport { shrinkit } from '../utils';\nimport MyAccount from './MyAccount';\nimport Dropdown from './Dropdown';\n\nexport default function Teacher(props) {\n    const { teacher } = props;\n    const [view, setView] = useState({ type: 'home' });\n    const [students, setStudents] = useState([]);\n    const [wearables, setWearables] = useState([]);\n    const [categories, setCategories] = useState([]);\n    const [badges, setBadges] = useState([]);\n    const getTeacherData = async () => {\n        const response = await fetch(`/teacher/${teacher._id}`);\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        setStudents(body.students);\n        setWearables(body.wearables);\n        setCategories(body.categories);\n        setBadges(body.badges);\n        if (view.type === 'student') {\n            const refreshCurrentStudent = (prevView) => {\n                let thisStudent = prevView.data;\n                let index = body.students.findIndex(student => student._id === thisStudent._id);\n                return body.students[index];\n            }\n            setView(prevView => ({\n                type: 'student',\n                data: refreshCurrentStudent(prevView)\n            }));\n        }\n    }\n    useEffect(() => {\n        getTeacherData();\n    }, [teacher._id]);\n    const generateStudentList = () => {\n        if (!students.length) return 'No students yet!';\n        const makeSureNameFits = (string) => {\n            if (string.length < 18) return string;\n            let shortenedString = string.substring(0, 17);\n            return shortenedString + '...';\n        }\n        const studentList = students.map(student => ({\n            value: student._id,\n            display: makeSureNameFits(student.firstName + ' ' + student.lastName)\n        }));\n        return (\n            <Dropdown\n                style={{ minWidth: '14rem' }}\n                restoreDefault={view.type !== 'student'}\n                defaultValue={{ value: null, display: 'Select one...' }}\n                listItems={studentList}\n                onChange={(_id) => setView({ type: 'student', data: students[students.findIndex(student => student._id === _id)] })}\n            />\n        );\n    }\n    const state = {\n        view,\n        students,\n        wearables,\n        categories,\n        badges,\n        updateView: setView,\n        refreshData: getTeacherData\n    }\n    return (\n        <Dashboard teacher={true}>\n            <Header>\n                <Nav>\n                    <button onClick={() => setView({ type: 'home' })}>Home</button>\n                    <button onClick={() => setView({ type: 'marketplace' })}>Marketplace</button>\n                    <button onClick={() => setView({ type: 'badges' })}>Badges</button>\n                </Nav>\n                <TeacherProfileDropdown {...props} {...state} />\n            </Header>\n            <Sidebar>\n                <h2>Students</h2>\n                {generateStudentList()}\n                <hr />\n                <div className=\"teacherCode\">\n                    Teacher code:<br />\n                    <b style={{ fontSize: '0.8rem' }}>{teacher._id}</b>\n                </div>\n            </Sidebar>\n            <Main {...props} {...state} />\n        </Dashboard>\n    );\n}\n\nfunction TeacherProfileDropdown(props) {\n    const { teacher } = props;\n    const [expanded, setExpanded] = useState(false);\n    const toggleExpanded = () => setExpanded(prevState => !prevState);\n    return (\n        <div className={`User${expanded ? ' expanded' : ''}`}>\n            <button onClick={toggleExpanded}>\n                <span className=\"name\">{teacher.firstName}</span>\n                <span className=\"caret\"></span>\n            </button>\n            <div className=\"pfp\" onClick={toggleExpanded}>\n                <img alt=\"pfp\" src={teacher.profilePic ? teacher.profilePic : 'assets/defaultpfp.jpg' } />\n            </div>\n            <ContextMenu\n              position={null}\n              ignoreClick={['.User .pfp', '.User > button']}\n              updateContextMenu={() => setExpanded(false)}\n              children={(\n                <ul>\n                    <li><button className=\"myAccount\" onClick={() => props.updateView({ type: 'account' })}>My Account</button></li>\n                    <li><button className=\"settings\" onClick={() => props.updateView({ type: 'settings' })}>Settings</button></li>\n                    <li><button className=\"logout\" onClick={props.logout}>Logout</button></li>\n                </ul>\n            )} />\n        </div>\n    )\n}\n\nfunction Main(props) {\n    const { view, teacher } = props;\n    switch (view.type) {\n        case 'home': return <Home {...props} />;\n        case 'student': return <ViewStudent {...props} student={view.data} />;\n        case 'marketplace': return <TeacherMarketplace {...props} />;\n        case 'badges': return <TeacherBadges {...props} />;\n        case 'account': return <MyAccount {...props} userType=\"teacher\" user={teacher} />;\n        case 'settings': return <Settings {...props} />;\n        default: return <Home {...props} />;\n    }\n}\n\nfunction Home() {\n    return (\n        <div className=\"Main padme\">\n            <h1>Dashboard</h1>\n            <ul>\n                <li>View student dashboard</li>\n                <ul>\n                    <li>Add homework</li>\n                    <li>Log assignment progress</li>\n                    <li>Give coins</li>\n                    <li>Award badges</li>\n                </ul>\n                <li>General - apply to all students</li>\n                <ul>\n                    <li>Add/edit/delete badges</li>\n                    <li>Add/edit/delete closet items</li>\n                </ul>\n            </ul>\n        </div>\n    );\n}\n\nfunction TeacherMarketplace(props) {\n    const { teacher, modal } = props;\n    const [wearableModal, setWearableModal] = useState(false);\n    useEffect(() => {\n        if (!modal) setWearableModal(false);\n    }, [modal]);\n    useEffect(() => {\n        if (wearableModal) addNewWearable();\n    }, [teacher]);\n    const addNewWearable = () => {\n        props.updateModal(<AddOrEditWearable {...props} />);\n        setWearableModal(true);\n    }\n    return (\n        <div className=\"Main\">\n            <h1>Marketplace</h1>\n            <Marketplace {...props} viewingAsTeacher={true} />\n            <button onClick={addNewWearable}>Add new wearable</button>\n        </div>\n    );\n}\n\nfunction TeacherBadges(props) {\n    const addNewBadge = () => {\n        props.updateModal(<AddOrEditBadge {...props} />)\n    }\n    return (\n        <div className=\"Main\">\n            <h1>Badges</h1>\n            <Badges {...props} />\n            <button onClick={addNewBadge}>Add new badge</button>\n        </div>\n    )\n}\n\nfunction Badges(props) {\n    const { badges } = props;\n    const badgesRef = useRef({});\n    const awardBadge = (_id) => {\n        const index = badges.findIndex(badge => badge._id === _id);\n        const thisBadge = badges[index];\n        props.updateModal(<AwardBadge {...props} badge={thisBadge} />);\n    }\n    const editOrDeleteBadge = (e, _id) => {\n        e.preventDefault();\n        const index = badges.findIndex(badge => badge._id === _id);\n        const thisBadge = badges[index];\n        const editBadge = () => props.updateModal(<AddOrEditBadge {...props} badge={thisBadge} />);\n        const deleteBadge = () => {\n            const handleDelete = async () => {\n                props.updateModal(content({ loadingIcon: true }));\n                const response = await fetch(`/badge/${_id}`, { method: 'DELETE' });\n                const body = await response.json();\n                if (!body) return console.log('no response from server');\n                if (!body.success) return console.log('no success response from server');\n                shrinkit(badgesRef.current[_id], true);\n                props.refreshTeacher();\n                props.refreshData();\n                props.updateModal(false);\n            }\n            let content = (options = {\n                loadingIcon: false\n            }) => (\n                <div className=\"modalBox\">\n                    <h2>Are you sure?</h2>\n                    <img alt={thisBadge.name} src={thisBadge.src} style={{ float: 'right' }} />\n                    Are you sure you want to delete the badge \"{thisBadge.name}\"? This action cannot be undone.\n                    <div className=\"buttons\">\n                        {options.loadingIcon\n                            ?   <Loading />\n                            :   <form onSubmit={handleDelete}>\n                                    <button type=\"submit\">Yes, I'm sure</button>\n                                    <button type=\"button\" className=\"greyed\" onClick={() => props.updateModal(false)}>Cancel</button>\n                                </form>\n                            }\n                    </div>\n                </div>\n            )\n            props.updateModal(content());\n        }\n        let content = (\n            <ul className=\"editDelete\">\n                <li><button onClick={editBadge}>Edit</button></li>\n                <li><button onClick={deleteBadge}>Delete</button></li>\n            </ul>\n        );\n        props.updateContextMenu(e, content);\n    }\n    const generateBadgeList = () => {\n        return badges.map(badge => (\n            <div\n              key={`badgeList-${badge._id}`}\n              ref={(el) => badgesRef.current[badge._id] = el}\n              className=\"badgeItem\">\n                <img\n                  alt={badge.name}\n                  src={badge.src}\n                  className=\"badgeImage\"\n                  onClick={() => awardBadge(badge._id)}\n                  onContextMenu={(e) => editOrDeleteBadge(e, badge._id)} />\n                <span className=\"badgeName\">{badge.name}</span>\n                <span>\n                    <img alt=\"coin icon\" className=\"coin\" src=\"assets/Coin_ico.png\" />\n                    <span className=\"badgeValue\">{badge.value}</span>\n                </span>\n            </div>\n        ));\n    }\n    return (\n        <div className=\"BadgeList\">\n            {generateBadgeList()}\n        </div>\n    )\n}\n\nfunction AwardBadge(props) {\n    const { students, badge } = props;\n    const [recipient, setRecipient] = useState(null); // student id\n    const [error, setError] = useState(false);\n    const [loadingIcon, setLoadingIcon] = useState(false);\n    const makeSureNameFits = (string) => {\n        if (string.length < 18) return string;\n        let shortenedString = string.substring(0, 17);\n        return shortenedString + '...';\n    }\n    const studentList = students.map(student => ({\n        value: student._id,\n        display: makeSureNameFits(student.firstName + ' ' + student.lastName)\n    }));\n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        if (!recipient) return setError('Please select a student!');\n        setLoadingIcon(true);\n        const response = await fetch(`/student/${recipient}/badges`, {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ badgeId: badge._id })\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) {\n            setLoadingIcon(false);\n            return setError(body.error);\n        }\n        props.updateModal(false);\n        props.refreshData();\n    }\n    const updateRecipient = (_id) => {\n        setError(false);\n        setRecipient(_id);\n    }\n    return (\n        <div className=\"modalBox\">\n            <h2>Award this badge</h2>\n            <p>Choose a student to award this badge to:</p>\n            <div style={{ textAlign: 'center' }}>\n                <Dropdown\n                    style={{ minWidth: '15rem', marginBottom: '0.2rem' }}\n                    defaultValue={{ value: null, display: 'Select one...' }}\n                    listItems={studentList}\n                    onChange={updateRecipient}/>\n                {error && <span className=\"error\">{error}</span>}\n            </div>\n            <form onSubmit={handleSubmit} className=\"buttons\">\n                {loadingIcon\n                    ? <Loading />\n                    : <input type=\"submit\" />\n                }\n            </form>\n        </div>\n    )\n}\n\nfunction AddOrEditBadge(props) {\n    const { teacher, badge } = props;\n    const [loadingIcon, setLoadingIcon] = useState(false);\n    const [formData, setFormData] = useState({\n        _id: badge ? badge._id : '',\n        teacherCode: badge ? badge.teacherCode : teacher._id,\n        name: badge ? badge.name : '',\n        src: badge ? badge.src : '',\n        value: badge ? badge.value : ''\n    });\n    const updateFormData = (key, value) => {\n        setFormData(prevState => ({\n            ...prevState,\n            [key]: value\n        }));\n    }\n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        setLoadingIcon(true);\n        const ROUTE = badge ? `/badge/${badge._id}` : '/badge';\n        const response = await fetch(ROUTE, {\n            method: badge ? 'PUT' : 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(formData)\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        props.updateModal(false);\n        props.refreshData();\n    }\n    return (\n        <div className=\"modalBox\">\n            <form className=\"pad\" onSubmit={handleSubmit}>\n                <h2>{badge ? 'Edit this' : 'Add new'} badge</h2>\n                <label htmlFor=\"name\">Badge name:</label>\n                <input type=\"text\" defaultValue={badge ? badge.name : ''} onChange={(e) => updateFormData('name', e.target.value)} />\n                <label htmlFor=\"src\">Image link:</label>\n                <input type=\"text\" defaultValue={badge ? badge.src : ''} onChange={(e) => updateFormData('src', e.target.value)} />\n                <label htmlFor=\"value\">Badge value:</label>\n                <input type=\"text\" defaultValue={badge ? badge.value : ''} onChange={(e) => updateFormData('value', e.target.value)} />\n                <div className=\"buttons\">\n                    {loadingIcon\n                        ? <Loading />\n                        : <input type=\"submit\" />\n                    }\n                </div>\n            </form>\n        </div>\n    )\n}\n\nfunction Settings(props) {\n    return (\n        <div className=\"Main\">\n            <h1>Settings</h1>\n        </div>\n    );\n}","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Marketplace.js",["110","111","112"],"import { useState, useEffect, useRef } from 'react';\nimport Loading from './Loading';\nimport { shrinkit } from '../utils';\nimport Dropdown from './Dropdown';\nimport PianopetBase from './PianopetBase';\nimport Splat from './Splat';\nimport { ntc } from '../utils/ntc';\n\nexport default function Marketplace(props) {\n    const { viewingAsTeacher, student, avatar, teacher, wearables, categories, isMobile } = props;\n    const [preview, setPreview] = useState(null);\n    const [category, setCategory] = useState(() => categories[0]);\n    const wearableRefs = useRef({});\n    useEffect(() => {\n        if (avatar) setPreview(avatar);\n        else setPreview({});\n    }, [avatar]);\n    useEffect(() => {\n        // this useEffect is for when the teacher is editing a wearable (e.g. updating image source/coords, color hex) while previewing that\n        // same wearable in the preview box - when 'wearables' array is refetched after submit, we loop through the preview object and update it\n        // with the most recent information\n        const previewIsEmpty = !preview || (preview && Object.keys(preview).length === 0);\n        if (!viewingAsTeacher || previewIsEmpty) return;\n        const updatedPreviewObject = (preview) => {\n            const updatedObject = {};\n            for (let categoryName in preview) {\n                const wearableId = preview[categoryName]._id;\n                const getWearableObjectFromId = (id) => {\n                    const wearable = wearables.find(item => item._id === id);\n                    return wearable;\n                }\n                const wearable = getWearableObjectFromId(wearableId);\n                const category = getCategoryObject.fromId(wearable.category);\n                const { _id, name, src, value, image } = getWearableObjectFromId(wearableId)\n                updatedObject[category.name] = { _id, name, src, value, image };\n            }\n            return updatedObject;\n        }\n        setPreview(prevState => updatedPreviewObject(prevState));\n    }, [wearables]);\n    const getCategoryObject = {\n        fromName: (name) => categories.find(item => item.name === name),\n        fromId: (id) => categories.find(item => item._id === id)\n    }\n    const updatePreview = ({ category, _id, name, src, value, image }) => {\n        const updatePreviewFor = (type) => {\n            const categoryName = getCategoryObject.fromId(category)?.name || category; // in case of default\n            const [object, setObject] = type === 'preview'\n                ? [preview, setPreview]\n                : [avatar, props.updateAvatar];\n            if (object?.[categoryName]?.name === name) {\n                const previewObjectMinusCategory = (prevState) => {\n                    const obj = {...prevState};\n                    delete obj[categoryName];\n                    return obj;\n                }\n                setObject(prevState => ({\n                    ...previewObjectMinusCategory(prevState)\n                }));\n                return;\n            }\n            setObject(prevState => ({\n                ...prevState,\n                [categoryName]: { _id, name, src, value, image }\n            }));\n        }\n        if (isMobile) updatePreviewFor('avatar');\n        else updatePreviewFor('preview');\n    }\n    const teacherOperations = {\n        addColor: () => {\n            const content = (<AddOrEditColor {...props} category={getCategoryObject.fromName('Color')} />);\n            props.updateModal(content);\n        },\n        editOrDeleteWearable: (e, _id, type) => {\n            e.preventDefault();\n            if (!viewingAsTeacher) return;\n            const index = wearables.findIndex(wearable => wearable._id === _id);\n            const thisWearable = wearables[index];\n            const dialog = type === 'color'\n                ? <AddOrEditColor {...props} wearable={thisWearable} category={getCategoryObject.fromName('Color')} />\n                : <AddOrEditWearable {...props} wearable={thisWearable} category={getCategoryObject.fromId(thisWearable.category)} />;\n            const editWearable = () => props.updateModal(dialog);\n            const deleteWearable = () => {\n                const handleDelete = async (e) => {\n                    e.preventDefault();\n                    props.updateModal(content({ loadingIcon: true }));\n                    const response = await fetch(`/wearable/${_id}`, { method: 'DELETE' });\n                    const body = await response.json();\n                    if (!body) return console.log('no response from server');\n                    if (!body.success) return console.log('no success response from server');\n                    shrinkit(wearableRefs.current[_id], true);\n                    props.refreshTeacher();\n                    props.refreshData();\n                    props.updateModal(false);\n                }\n                let content = (options = {\n                    loadingIcon: false\n                }) => (\n                    <div className=\"modalBox hasImage\">\n                        <div>\n                            <h2>Are you sure?</h2>\n                            Are you sure you want to delete the {type === 'color' ? 'color' : 'wearable'} \"{thisWearable.name}\"? This action cannot be undone.\n                            <div className=\"buttons\">\n                                {options.loadingIcon\n                                    ?   <Loading />\n                                    :   <form onSubmit={handleDelete}>\n                                            <button type=\"submit\">Yes, I'm sure</button>\n                                            <button type=\"button\" className=\"greyed\" onClick={() => props.updateModal(false)}>Cancel</button>\n                                        </form>\n                                    }\n                            </div>\n                        </div>\n                        <div className=\"flex center\">\n                            {type === 'color'\n                                ? <Splat color={thisWearable.src} />\n                                : <img alt={thisWearable.name} src={thisWearable.src} />}\n                        </div>\n                    </div>\n                )\n                props.updateModal(content());\n            }\n            let content = (\n                <ul className=\"editDelete\">\n                    <li><button onClick={editWearable}>Edit</button></li>\n                    <li><button onClick={deleteWearable}>Delete</button></li>\n                </ul>\n            );\n            props.updateContextMenu(e, content);\n        },\n        addOrEditCategory: (e, category) => {\n            e.preventDefault();\n            if (!viewingAsTeacher) return;\n            const originalName = category?.name;\n            const editingCategory = !!category;\n            const handleAddOrEditCategory = async (e, categoryName) => {\n                e.preventDefault();\n                props.updateModal(content({ loadingIcon: true }));\n                const fromDropdown = !!categoryName;\n                const formData = editingCategory\n                    ?   {\n                            _id: category._id,\n                            categoryName: e.target[0].value\n                        }\n                    :   { categoryName: fromDropdown ? categoryName : e.target[0].value }\n                const response = await fetch(`/teacher/${teacher._id}/wearable-category`, {\n                    method: editingCategory ? 'PUT' : 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(formData)\n                });\n                const body = await response.json();\n                if (!body) return console.log('no response from server');\n                if (!body.success) return console.log('no success response from server');\n                props.refreshData();\n                if (editingCategory) {\n                    props.refreshData(); // in case any wearables were affected by category name change\n                    if (category === originalName) setCategory(e.target[0].value);\n                }\n                props.updateModal(false);\n            }\n            let content = (options = {\n                loadingIcon: false\n            }) => (\n                <div className=\"modalBox\">\n                    <h2>{editingCategory ? 'Edit' : 'Add new'} category</h2>\n                    <form onSubmit={handleAddOrEditCategory} autoComplete=\"off\">\n                        <label htmlFor=\"categoryName\">Category name:</label>\n                        <input type=\"text\" name=\"categoryName\" defaultValue={editingCategory ? originalName : ''} />\n                        <div className=\"buttons\">\n                            {options.loadingIcon\n                                ? <Loading />\n                                : <input type=\"submit\" />\n                            }\n                        </div>\n                    </form>\n                </div>\n            );\n            if (originalName === 'Color') content = (\n                <div className=\"modalBox\">\n                    <h2>Not allowed</h2>\n                    Sorry, this is a default category and can't be renamed.\n                    <div className=\"buttons\"><button onClick={() => props.updateModal(false)}>Go back</button></div>\n                </div>\n            )\n            props.updateModal(content);\n        },\n        confirmDeleteCategory: (category) => {\n            // check if empty\n            let content;\n            const handleDelete = async (e, reassignWearables = false) => {\n                e.preventDefault();\n                props.updateModal(content({ loadingIcon: true }));\n                const response = await fetch(`/teacher/${teacher._id}/wearable-category`, {\n                    method: 'DELETE',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        _id: category._id,\n                        reassignWearables\n                    })\n                });\n                const body = await response.json();\n                if (!body) return console.log('no response from server');\n                if (!body.success) return console.log('no success response from server');\n                //todo shrink it down in the list before it disappears\n                props.refreshData();\n                props.updateModal(false);\n            }\n            const categoryIsEmpty = (() => !wearables.some(wearable => wearable.category === category._id))();\n            if (categoryIsEmpty) content = (options = {\n                loadingIcon: false\n            }) => (\n                <div className=\"modalBox\">\n                    <h2>Delete this category</h2>\n                    Are you sure you want to delete the category \"{category.name}\"?\n                    {options.loadingIcon\n                        ?   <Loading />\n                        :   <form className=\"buttons\" onSubmit={handleDelete}>\n                                <button type=\"submit\">Yes, I'm sure</button>\n                                <button type=\"button\" className=\"greyed\" onClick={() => props.updateModal(false)}>Cancel</button>\n                            </form>\n                        }\n                </div>\n            );\n            else content = () => <div>you need to move the contents to a different category then</div>;\n            props.updateModal(content());\n        },\n        editOrDeleteCategory: (e, category) => {\n            if (!viewingAsTeacher) return;\n            e.preventDefault();\n            let content = (\n                <ul className=\"editDelete\">\n                    <li><button onClick={(e) => teacherOperations.addOrEditCategory(e, category)}>Edit</button></li>\n                    <li><button onClick={(e) => teacherOperations.confirmDeleteCategory(category)}>Delete</button></li>\n                </ul>\n            );\n            props.updateContextMenu(e, content);\n        }\n    }\n    const studentOperations = {\n        buyWearable: ({ _id, name, src, value, image }) => {\n            if (viewingAsTeacher) return;\n            const buyingColor = !image;\n            const handleSubmit = async (e) => {\n                e.preventDefault();\n                if (student.coins < value) {\n                    let cantAfford = (\n                        <div className=\"modalBox\">\n                            <h2>Not enough coins</h2>\n                            You don't have enough coins to purchase this item. It costs {value} and you only have {student.coins}.\n                            <div className=\"buttons\">\n                                <button type=\"button\" onClick={() => props.updateModal(false)}>OK</button>\n                            </div>\n                        </div>\n                    );\n                    props.updateModal(cantAfford);\n                    return;\n                }\n                props.updateModal(content({ loadingIcon: true }));\n                const response = await fetch(`/student/${student._id}/closet`, {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        wearableId: _id,\n                        wearableCost: value\n                    })\n                });\n                const body = await response.json();\n                if (!body) return console.log('no response from server');\n                if (!body.success) return console.log('no success response from server');\n                props.refreshData();\n                props.updateModal(false);\n            }\n            let content = (options = {\n                loadingIcon: false\n            }) => (\n                <div className=\"modalBox hasImage\">\n                    <div>\n                        <h2>Confirm purchase</h2>\n                        Are you sure you want to purchase {buyingColor && 'the color'} <b>{name}</b> for <span className=\"coins\"><b>{value}</b>?</span>\n                        <div className=\"buttons\">\n                            {options.loadingIcon\n                                ?   <Loading />\n                                :   <form onSubmit={handleSubmit}>\n                                        <button type=\"submit\">Yes, I'm sure</button>\n                                        <button type=\"button\" className=\"greyed\" onClick={() => props.updateModal(false)}>Cancel</button>\n                                    </form>\n                                }\n                        </div>\n                    </div>\n                    <div className=\"flex center\">\n                        {buyingColor\n                            ? <PianopetBase color={src} zoom={true} />\n                            : <img alt={name} src={src} />\n                        }\n                    </div>\n                </div>\n            );\n            props.updateModal(content());\n        }\n    }\n    const generate = {\n        previewObject: (preview) => {\n            if (isMobile) return null;\n            const images = [];\n            for (let category in preview) {\n                if (category !== 'Color') {\n                    const thisWearable = preview[category];\n                    const style = {\n                        top: `${thisWearable.image.y}%`,\n                        left: `${thisWearable.image.x}%`,\n                        width: `${thisWearable.image.w}%`\n                    }\n                    images.push(\n                        <img\n                            alt={thisWearable.name}\n                            key={`marketplacePreview-${category}`}\n                            className={`previewWearable ${category}`}\n                            src={thisWearable.src}\n                            style={style}\n                        />\n                    );\n                }\n            }\n            return (\n                <div className=\"previewBox\">\n                    {preview && <PianopetBase color={preview?.Color?.src} />}\n                    {images}\n                </div>\n            );\n        },\n        previewDescription: (preview) => {\n            if (viewingAsTeacher || isMobile) return;\n            const previewItems = [];\n            for (let category in preview) {\n                if (!preview[category]._id) break; // default color _id is undefined\n                const isOwned = student.closet.includes(preview[category]._id);\n                previewItems.push(\n                    <li key={`marketplacePreviewDescription-${category}`}>\n                        <span className=\"wearableName\">{preview[category].name}</span>\n                        {!viewingAsTeacher && isOwned\n                            ?   <span className=\"owned\"></span>\n                            :   <button onClick={() => studentOperations.buyWearable(preview[category])}>\n                                    <img className=\"coin\" alt=\"coin icon\" src=\"assets/Coin_ico.png\" />\n                                    <span className=\"wearableValue\">{preview[category].value}</span>\n                                </button>\n                            }\n                    </li>\n                )\n            }\n            return (\n                <ul>\n                    <h3>Previewing:</h3>\n                    {previewItems}\n                </ul>\n            );\n        },\n        categoriesList: (categories) => {\n            const array = categories.map(category => (\n                <button\n                  key={`wearableCategories-toolbar-${category.name}`}\n                  onClick={() => setCategory(category)}\n                  onContextMenu={(e) => teacherOperations.editOrDeleteCategory(e, category)}>\n                    {category.name}\n                </button>\n            ))\n            if (viewingAsTeacher) array.push(\n                <button key=\"wearableCategories-toolbar-addNew\" className=\"add\" onClick={teacherOperations.addOrEditCategory}></button>\n            );\n            return array;\n        },\n        wearablesList: (category) => {\n            const filteredList = wearables.filter(wearable => wearable.category === category._id);\n            const list = filteredList.map(wearable => {\n                const ownsWearable = (() => {\n                    if (viewingAsTeacher) return false;\n                    if (student.closet.includes(wearable._id)) return true;\n                    return false;\n                })();\n                const type = category.name === 'Color' ? 'color' : 'wearable';\n                return (\n                    <button\n                      ref={(el) => wearableRefs.current[wearable._id] = el}\n                      key={`${category.name}-wearable-${wearable.name}`}\n                      className={ownsWearable ? 'owned' : ''}\n                      onClick={() => updatePreview(wearable)}\n                      onContextMenu={(e) => teacherOperations.editOrDeleteWearable(e, wearable._id, type)}>\n                        {category.name === 'Color'\n                            ? <Splat color={wearable.src} />\n                            : <img alt={wearable.name} src={wearable.src} />}\n                        <span>{wearable.name}</span>\n                        <span>\n                            <img alt=\"coin icon\" src=\"assets/Coin_ico.png\" />\n                            <span>{wearable.value}</span>\n                        </span>\n                    </button>\n                )\n            });\n            if (viewingAsTeacher && category.name === 'Color') list.push(\n                <button key=\"color-wearable-addNew\" className=\"add\" onClick={teacherOperations.addColor}></button>\n            );\n            if (category.name === 'Color') list.splice(0, 0, (\n                <button\n                    ref={(el) => wearableRefs.current['default'] = el}\n                    key={`Color-wearable-defaultColor`}\n                    className={viewingAsTeacher ? null : \"owned\"}\n                    onClick={() => updatePreview({ category: 'Color', src: '#5C76AE' })}>\n                    <Splat color=\"#5C76AE\" />\n                    <span>Default</span>\n                    <span>\n                        <img alt=\"coin icon\" src=\"assets/Coin_ico.png\" />\n                        <span>0</span>\n                    </span>\n                </button>\n            ));\n            return list;\n        }\n    }\n    return (\n        <div className=\"Marketplace\">\n            <div id=\"demo\" onClick={() => console.dir(preview)}></div>\n            <div className=\"marketplacePreview\">\n                {generate.previewObject(preview)}\n                {generate.previewDescription(preview)}\n            </div>\n            <div className=\"wearableCategories\">\n                {generate.categoriesList(categories)}\n            </div>\n            <div className=\"wearablesList\">\n                <div className={category?.name === 'Color' ? 'blobs' : null}>\n                    {generate.wearablesList(category)}\n                </div>\n            </div>\n        </div>\n    );\n}\n\nfunction AddOrEditColor(props) {\n    const { teacher, wearable, category } = props;\n    const [loadingIcon, setLoadingIcon] = useState(false);\n    const [formData, setFormData] = useState({\n        teacherCode: teacher._id,\n        name: wearable ? wearable.name : '',\n        category: category._id,\n        src: wearable ? wearable.src : '#' + Math.floor(Math.random()*16777215).toString(16),\n        value: wearable ? wearable.value : ''\n    });\n    const colorInput = useRef(null);\n    const addingColor = !wearable;\n    const updateFormData = (e) => {\n        setFormData(prevState => ({\n            ...prevState,\n            [e.target.name]: e.target.value\n        }));\n    }\n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        setLoadingIcon(true);\n        const ROUTE = wearable ? `/wearable/${wearable._id}` : '/wearable';\n        const response = await fetch(ROUTE, {\n            method: wearable ? 'PUT' : 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(formData)\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        props.updateModal(false);\n        props.refreshData();\n    }\n    return (\n        <div className=\"modalBox\">\n            <form onSubmit={handleSubmit} autoComplete=\"off\">\n                <h2>{addingColor ? 'Add a new' : 'Edit this'} color</h2>\n                {addingColor ? 'Add a new' : 'Edit this'} color by clicking on the Pianopet icon below.\n                <div className=\"colorPicker\">\n                    <div>\n                        <PianopetBase color={formData.src} zoom={true} />\n                        <input name=\"src\" type=\"color\" defaultValue={formData.src} onChange={updateFormData} ref={colorInput} />\n                        <span onClick={() => colorInput.current.click()}></span>\n                    </div>\n                    <div>\n                        <label htmlFor=\"name\">Color name:</label>\n                        <input\n                            name=\"name\"\n                            type=\"text\"\n                            placeholder={`How about ${ntc.name(formData.src)[1]}?`}\n                            defaultValue={formData.name}\n                            onChange={updateFormData} />\n                    </div>\n                    <div>\n                        <label htmlFor=\"value\">Cost:</label>\n                        <input name=\"value\" type=\"text\" defaultValue={formData.value} onChange={updateFormData} />\n                    </div>\n                </div>\n                {addingColor || <div className=\"tip\" style={{ marginTop: '1rem' }}>Tip: Clear the text box to see color name suggestions!</div>}\n                {loadingIcon\n                    ?   <Loading />\n                    :   <div className=\"buttons\">\n                            <button type=\"submit\">Submit</button>\n                            <button type=\"button\" className=\"greyed\" onClick={() => props.updateModal(false)}>Cancel</button>\n                        </div>\n                    }\n            </form>\n        </div>\n    );\n}\n\nexport function AddOrEditWearable(props) {\n    const { teacher, wearable, category, categories } = props;\n    const [loadingIcon, setLoadingIcon] = useState(false);\n    const [formData, setFormData] = useState({\n        teacherCode: wearable ? wearable.teacherCode : teacher._id,\n        name: wearable ? wearable.name : '',\n        category: wearable ? category._id : categories[0]._id,\n        src: wearable ? wearable.src : '',\n        value: wearable ? wearable.value : '',\n        image: {\n            w: wearable && wearable.image ? wearable.image.w : 50,\n            x: wearable && wearable.image ? wearable.image.x : 10,\n            y: wearable && wearable.image ? wearable.image.y : 40\n        }\n    });\n    const [categoriesList, setCategoriesList] = useState(() => {\n        return categories.map(item => ({\n            value: item._id,\n            display: item.name\n        }));\n    });\n    const updateFormData = (key, value) => {\n        setFormData(prevState => ({\n            ...prevState,\n            [key]: value\n        }));\n    }\n    const updateImage = (newStuff) => {\n        setFormData(prevState => ({\n            ...prevState,\n            image: {\n                ...prevState.image,\n                ...newStuff\n            }\n        }));\n    }\n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        setLoadingIcon(true);\n        // if added new category via dropdown, need to set formData.category to new category ID bc right now it's set to category name!!!!\n        // refreshData() from addCategory() has already been called but updated 'categories' array isn't available here because we're inside the\n        // modal and the state is set... god dammit... ok temporary workaround\n        // first check if formData.category is among existing categories, in which case we can skip this whole charade\n        // if it is a new category, then find it by name (display) in the categoriesList array [{ value, display }] and replace it with its _id\n        let dataToSend = formData;\n        const isExistingCategory = (() => {\n            const index = categories.findIndex(item => item._id === formData.category);\n            return index !== -1;\n        })();\n        if (!isExistingCategory) {\n            const isValidCategory = (() => {\n                const obj = categoriesList.find(item => item.display === formData.category);\n                return obj; // can't imagine this would return undefined but just in case\n            })();\n            if (!isValidCategory) return;\n            let newCategory = isValidCategory;\n            dataToSend = {\n                ...formData,\n                category: newCategory.value\n            }\n        }\n        // by the way another reason we need a separate categoriesList array is to update the actual dropdown with the new option added\n        // since we're inside modal and the state of 'modal', all the way up in App.js, is set to this until updateModal() is called again\n        // what a fucking pain\n        // todo fix this shit\n        const ROUTE = wearable ? `/wearable/${wearable._id}` : '/wearable';\n        const response = await fetch(ROUTE, {\n            method: wearable ? 'PUT' : 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(dataToSend)\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        props.updateModal(false);\n        props.refreshData();\n    }\n    const addCategory = async (categoryName) => {\n        // this is happening first, then formData gets updated\n        const response = await fetch(`/teacher/${teacher._id}/wearable-category`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                _id: teacher._id,\n                categoryName\n            })\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        const { _id, name } = body.newCategory;\n        setCategoriesList(prevState => {\n            prevState.push({ value: _id, display: name });\n            return prevState;\n        });\n        props.refreshData();\n    }\n    const dropdownItems = {\n        defaultValue: () => {\n            const categoryName = wearable ? category.name : categories[0].name;\n            const categoryId = wearable ? category._id : categories[0]._id;\n            return {\n                value: categoryId,\n                display: categoryName\n            }\n        },\n        listItems: categoriesList\n    }\n    return (\n        <div className=\"modalBox\">\n            <h2>Add new wearable</h2>\n            <form className=\"pad\" onSubmit={handleSubmit}>\n                <div className=\"addWearableForm\">\n                    <div>\n                        <label htmlFor=\"name\">Wearable name:</label>\n                        <input\n                            type=\"text\"\n                            defaultValue={wearable ? wearable.name : ''}\n                            onChange={(e) => updateFormData('name', e.target.value)} />\n                        <label htmlFor=\"value\">Category:</label>\n                        <Dropdown\n                            minWidth=\"10rem\"\n                            defaultValue={dropdownItems.defaultValue()}\n                            listItems={dropdownItems.listItems}\n                            addNew={addCategory}\n                            onChange={(value) => updateFormData('category', value)} />\n                        <label htmlFor=\"src\">Image link:</label>\n                        <input type=\"text\" defaultValue={wearable ? wearable.src : ''} onChange={(e) => updateFormData('src', e.target.value)} />\n                        <label htmlFor=\"value\">Wearable value:</label>\n                        <input type=\"text\" defaultValue={wearable ? wearable.value : ''} onChange={(e) => updateFormData('value', e.target.value)} />\n                    </div>\n                    <AddOrEditWearablePreview src={formData.src} image={formData.image} updateImage={updateImage} />\n                </div>\n                <div className=\"buttons\">\n                    {loadingIcon\n                        ? <Loading />\n                        : <input type=\"submit\" />\n                    }\n                </div>\n            </form>\n        </div>\n    );\n}\n\nfunction AddOrEditWearablePreview(props) {\n    const { src, image } = props;\n    const [mouseIsDown, setMouseIsDown] = useState(false);\n    const [mouseIsMoving, setMouseIsMoving] = useState(false);\n    const [elementPosition, setElementPosition] = useState({\n        x: 0,\n        y: 0\n    });\n    const [elementOffset, setElementOffset] = useState(null);\n    const preview = useRef(null);\n    const draggable = useRef(null);\n    useEffect(() => {\n        const draggableObject = draggable.current;\n        const previewBox = preview.current;\n        if (!draggableObject || !previewBox) return;\n        setElementPosition({\n            x: (image.x * previewBox.scrollWidth) / 100,\n            y: (image.y * previewBox.scrollHeight) / 100\n        });\n        const mouseup = () => setMouseIsDown(false);\n        const mousedown = (e) => {\n            setMouseIsDown(e);\n            window.addEventListener('mouseup', mouseup);\n        }\n        draggableObject.addEventListener('mousedown', mousedown);\n        return () => {\n            draggableObject.removeEventListener('mousedown', mousedown);\n            window.removeEventListener('mouseup', mouseup);\n        }\n    // eslint-disable-next-line\n    }, []); // want this to run ONLY when the function mounts, not if/when image.x and image.y change (which they will)\n    useEffect(() => {\n        const previewBox = preview.current;\n        const mousemove = (e) => {\n            e.preventDefault();\n            setMouseIsMoving(e);\n        }\n        if (!mouseIsDown) {\n            setMouseIsDown(false);\n            setMouseIsMoving(false);\n            const calculateImageCoords = () => ({\n                x: (elementPosition.x * 100) / previewBox.scrollWidth,\n                y: (elementPosition.y * 100) / previewBox.scrollHeight\n            });\n            props.updateImage(calculateImageCoords());\n            previewBox.removeEventListener('mousemove', mousemove);\n            return;\n        }\n        const e = mouseIsDown; // mouseIsDown will have been set to the actual DOM mousedown event\n        const calculateElementOffset = (e) => {\n            const mouseX = e.clientX - previewBox.getBoundingClientRect().left;\n            const mouseY = e.clientY - previewBox.getBoundingClientRect().top;\n            const offsetX = mouseX - elementPosition.x;\n            const offsetY = mouseY - elementPosition.y;\n            setElementOffset({\n                x: offsetX,\n                y: offsetY\n            });\n        }\n        calculateElementOffset(e);\n        previewBox.addEventListener('mousemove', mousemove);\n        return () => previewBox.removeEventListener('mousemove', mousemove);\n    // eslint-disable-next-line\n    }, [mouseIsDown]); // todo double check eslint disable\n    useEffect(() => {\n        if (!mouseIsMoving) return;\n        const previewBox = preview.current;\n        const e = mouseIsMoving;\n        const mouseX = e.clientX - previewBox.getBoundingClientRect().left;\n        const mouseY = e.clientY - previewBox.getBoundingClientRect().top;\n        setElementPosition({\n            x: mouseX - elementOffset.x,\n            y: mouseY - elementOffset.y\n        });\n    }, [mouseIsMoving, elementOffset]);\n    const updateImageSize = (e) => {\n        e.preventDefault();\n        const percentage = parseInt(e.target.value) + 1;\n        const draggableObject = draggable.current;\n        draggableObject.style.width = percentage + '%';\n        props.updateImage({ w: percentage });\n    }\n    return (\n        <div>\n            <label>Preview:</label>\n            <div className=\"previewBox\">\n                <div ref={preview}>\n                    <PianopetBase />\n                    <img\n                    alt=\"preview\"\n                    src={src}\n                    ref={draggable}\n                    className={`draggable${mouseIsDown ? ' dragging' : ''}`}\n                    style={{\n                        width: image.w + '%',\n                        transform: `translate3d(${elementPosition.x}px, ${elementPosition.y}px, 0)`\n                        }} />\n                </div>\n            </div>\n            <input type=\"range\" defaultValue={image.w - 1} min=\"0\" max=\"99\" onChange={updateImageSize} />\n        </div>\n    );\n}\n\nfunction DeleteWearableCategory(props) {\n    const { category, categories, teacher } = props; // props.handleDelete\n    const [formData, setFormData] = useState({});\n    const [categoriesList, setCategoriesList] = useState(() => {\n        const array = categories.filter(item => item._id !== category._id);\n        return array.map(item => ({\n            value: item._id,\n            display: item.name\n        }));\n    });\n    const updateFormData = (key, value) => {\n        setFormData(prevState => ({\n            ...prevState,\n            [key]: value\n        }));\n    }\n    const dropdownItems = {\n        defaultValue: categoriesList[0],\n        listItems: categoriesList\n    }\n    const addCategory = async (categoryName) => {\n        const response = await fetch(`/teacher/${teacher._id}/wearable-category`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                _id: teacher._id,\n                categoryName\n            })\n        });\n        const body = await response.json();\n        if (!body) return console.log('no response from server');\n        if (!body.success) return console.log('no success response from server');\n        const { _id, name } = body.newCategory;\n        setCategoriesList(prevState => {\n            prevState.push({ value: _id, display: name });\n            return prevState;\n        });\n        props.refreshData();\n    }\n    return (\n        <div className=\"modalBox\">\n            <h2>Delete category</h2>\n            The category \"{category.name}\" contains X number of wearables. If you want to delete it, you need to move them to a different category.\n            <div>\n                <label>Select a category:</label>\n                <Dropdown\n                    minWidth=\"10rem\"\n                    defaultValue={dropdownItems.defaultValue}\n                    listItems={dropdownItems.listItems}\n                    addNew={addCategory}\n                    onChange={(value) => updateFormData('category', value)} />\n            </div>\n        </div>\n    )\n}","/Users/ngw/Documents/Sites/Pianopet/client/src/components/ViewStudent.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/ContextMenu.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Dropdown.js",["113"],"import { useEffect, useRef, useState } from 'react';\nimport { elementHasParent } from '../utils';\n\nexport default function Dropdown(props) {\n    const { defaultValue, listItems, restoreDefault } = props;\n    const [display, setDisplay] = useState(() => {\n        if (!listItems || !listItems.length) return 'Add new...';\n        if (!defaultValue) return 'Select one';\n        return defaultValue.display;\n    });\n    const [isOpen, setIsOpen] = useState(false);\n    const [addingNew, setAddingNew] = useState(false);\n    const dropdownList = useRef(null);\n    useEffect(() => {\n        const closeDropdown = (e) => {\n            if (elementHasParent(e.target, '.dropdownDisplay')) return;\n            if (elementHasParent(e.target, '.addNew')) return;\n            setIsOpen(false);\n        }\n        window.addEventListener('click', closeDropdown);\n        return () => window.removeEventListener('click', closeDropdown);\n    }, []);\n    useEffect(() => {\n        if (!dropdownList || !dropdownList.current) return;\n        if (isOpen) dropdownList.current.style.maxHeight = dropdownList.current.scrollHeight + 1 + 'px'; // plus 1px to account for 1px bottom border\n        else {\n            dropdownList.current.style.maxHeight = '0px';\n            setAddingNew(false); // unrelated to maxHeight adjustment thing\n        }\n    }, [isOpen]);\n    useEffect(() => {\n        if (addingNew) dropdownList.current.style.maxHeight = dropdownList.current.scrollHeight + 1 + 'px';\n    }, [addingNew]);\n    useEffect(() => {\n        if (restoreDefault) setDisplay(defaultValue.display);\n    // defaultValue is guaranteed to stay the same during the lifetime of this component so I think it's safe to include here?\n    // but maybe read up on if it's better to eslint-disable-next-line instead\n    }, [restoreDefault, defaultValue.display]);\n    const toggleIsOpen = () => setIsOpen(prevState => !prevState);\n    const handleClick = (e) => {\n        setDisplay(e.target.innerHTML);\n        props.onChange(e.target.getAttribute('data-value'));\n    }\n    const generateList = () => {\n        const buttonForAddNew =\n            <AddNew {...props}\n                key=\"dropdownItem-addNew\"\n                addingNew={addingNew}\n                updateAddingNew={setAddingNew}\n                updateIsOpen={setIsOpen}\n                updateDisplay={setDisplay}\n            />;\n        if ((!listItems || !listItems.length) && props.addNew) {\n            console.table(listItems);\n            return buttonForAddNew;\n        }\n        const array = [];\n        for (let item of listItems) {\n            array.push(\n                <li className=\"dropdownItem\" key={`dropdownItem-${item.value}`}>\n                    <button type=\"button\" data-value={item.value} onClick={handleClick}>{item.display}</button>\n                </li>\n            );\n        }\n        if (props.addNew) array.push(buttonForAddNew);\n        return array;\n    }\n    return (\n        <div className={`Dropdown${isOpen ? ' expanded' : ''}`} style={props.style}>\n            <div className=\"dropdownDisplay\" onClick={toggleIsOpen}>{display}</div>\n            <ul className=\"dropdownList\" ref={dropdownList}>{generateList()}</ul>\n        </div>\n    );\n}\n\nfunction AddNew(props) {\n    const { addingNew } = props;\n    const [inputValue, setInputValue] = useState(null);\n    const inputRef = useRef(null);\n    useEffect(() => {\n        if (!addingNew) return setInputValue(null);\n        inputRef.current.focus();\n        const handleKeydown = (e) => {\n            if (e.key === 'Escape') return props.updateAddingNew(false);\n            if (e.key === 'Enter') {\n                e.preventDefault();\n                props.addNew(inputRef.current.value);\n                props.updateDisplay(inputRef.current.value);\n                props.onChange(inputRef.current.value);\n                props.updateIsOpen(false);\n                return;\n            }\n        }\n        window.addEventListener('keydown', handleKeydown);\n        return () => window.removeEventListener('keydown', handleKeydown);\n    }, [addingNew]);\n    return (\n        <li className=\"dropdownItem\">\n            {addingNew\n                ?   <button type=\"button\" className=\"addNew active\">\n                        <input\n                            ref={inputRef}\n                            type=\"text\"\n                            defaultValue={inputValue}\n                            onChange={(e) => setInputValue(e.target.value)}\n                        />\n                        <span className=\"inputHint\">Press Enter to submit, Esc to cancel.</span>\n                    </button>\n                :   <button type=\"button\" className=\"addNew\" onClick={() => props.updateAddingNew(true)}>\n                        {props.buttonContent || 'Add new...'}\n                    </button>\n                }\n        </li>\n    )\n}","/Users/ngw/Documents/Sites/Pianopet/client/src/components/Avatar.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Closet.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Button.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/MyAccount.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/PianopetBase.js",[],"/Users/ngw/Documents/Sites/Pianopet/client/src/utils/ntc.js",[],["114","115"],"/Users/ngw/Documents/Sites/Pianopet/client/src/components/Splat.js",[],{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","replacedBy":"119"},{"ruleId":"116","replacedBy":"120"},{"ruleId":"118","replacedBy":"121"},{"ruleId":"116","replacedBy":"122"},{"ruleId":"118","replacedBy":"123"},{"ruleId":"124","severity":1,"message":"125","line":41,"column":8,"nodeType":"126","endLine":41,"endColumn":21,"suggestions":"127"},{"ruleId":"124","severity":1,"message":"128","line":167,"column":8,"nodeType":"126","endLine":167,"endColumn":17,"suggestions":"129"},{"ruleId":"124","severity":1,"message":"130","line":40,"column":8,"nodeType":"126","endLine":40,"endColumn":19,"suggestions":"131"},{"ruleId":"132","severity":1,"message":"133","line":768,"column":10,"nodeType":"134","messageId":"135","endLine":768,"endColumn":32},{"ruleId":"132","severity":1,"message":"136","line":770,"column":12,"nodeType":"134","messageId":"135","endLine":770,"endColumn":20},{"ruleId":"124","severity":1,"message":"137","line":96,"column":8,"nodeType":"126","endLine":96,"endColumn":19,"suggestions":"138"},{"ruleId":"116","replacedBy":"139"},{"ruleId":"118","replacedBy":"140"},"no-native-reassign",["141"],"no-negated-in-lhs",["142"],["141"],["142"],["141"],["142"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getTeacherData'. Either include it or remove the dependency array.","ArrayExpression",["143"],"React Hook useEffect has missing dependencies: 'addNewWearable' and 'wearableModal'. Either include them or remove the dependency array.",["144"],"React Hook useEffect has missing dependencies: 'getCategoryObject', 'preview', and 'viewingAsTeacher'. Either include them or remove the dependency array.",["145"],"no-unused-vars","'DeleteWearableCategory' is defined but never used.","Identifier","unusedVar","'formData' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["146"],["141"],["142"],"no-global-assign","no-unsafe-negation",{"desc":"147","fix":"148"},{"desc":"149","fix":"150"},{"desc":"151","fix":"152"},{"desc":"153","fix":"154"},"Update the dependencies array to be: [getTeacherData, teacher._id]",{"range":"155","text":"156"},"Update the dependencies array to be: [addNewWearable, teacher, wearableModal]",{"range":"157","text":"158"},"Update the dependencies array to be: [getCategoryObject, preview, viewingAsTeacher, wearables]",{"range":"159","text":"160"},"Update the dependencies array to be: [addingNew, props]",{"range":"161","text":"162"},[1691,1704],"[getTeacherData, teacher._id]",[6425,6434],"[addNewWearable, teacher, wearableModal]",[2018,2029],"[getCategoryObject, preview, viewingAsTeacher, wearables]",[4057,4068],"[addingNew, props]"]